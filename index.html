<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mezo Plays Pokémon – ChainPlays UI</title>
  <style>
    /* Mezo brand theme: charcoal + hot pink accent */
    :root {
      --bg: #0b0a0e;            /* page background (near-black with a hint of magenta) */
      --card: #101018;          /* cards & panels */
      --text: #f3f4f6;          /* primary text */
      --sub: #b6bac7;           /* secondary text */
      --accent: #ff0050;        /* Mezo pink */
      --edge: #2a0d1a;          /* borders (pink-tinted charcoal) */
      --edge-soft: #1a0a12;     /* subtle borders */
      --surface: #0f0e15;       /* inputs/buttons base */
      --surface-2: #14121a;     /* badges/mono blocks */
    }

    body { margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; }
    .wrap { max-width:880px; margin:40px auto; padding:24px; }
    .card { background:var(--card); border:1px solid var(--edge); border-radius:16px; padding:20px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
    h1 { font-size:28px; margin:0 0 8px; }
    p { color:var(--sub); margin:0 0 16px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

    button, input { height:44px; border-radius:10px; border:1px solid var(--edge); background:var(--surface); color:var(--text); padding:0 14px; font-weight:600; }
    select { height:44px; border-radius:10px; border:1px solid var(--edge); background:var(--surface); color:var(--text); padding:0 14px; font-weight:600; }
    /* override inline styles on the chain select if present */
    select#chain { background: var(--surface) !important; border-color: var(--edge) !important; color: var(--text) !important; }

    button { cursor:pointer; }
    button.primary { background:linear-gradient(180deg, #ff2b6a, #ff0050); border-color:#b8003b; color:#fff; }
    button:hover { filter:brightness(1.06); }

    .pad { display:grid; grid-template-columns:repeat(3,100px); gap:10px; justify-content:center; margin-top:10px; }
    .pad button { height:64px; font-size:18px; background:linear-gradient(180deg, #ff2b6a, #ff0050); border-color:#b8003b; color:#fff; }
    .pad button:disabled { opacity:.65; cursor:wait; }
    .keys { display:grid; grid-template-columns:repeat(2,100px); gap:10px; justify-content:center; margin-top:10px; }
    .keys button { background:linear-gradient(180deg, #ff2b6a, #ff0050); border-color:#b8003b; color:#fff; }
    .keys button:disabled { opacity:.65; cursor:wait; }
    .keys { display:grid; grid-template-columns:repeat(2,100px); gap:10px; justify-content:center; margin-top:10px; }

    .stat { font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:var(--surface-2); border:1px solid var(--edge-soft); padding:10px 12px; border-radius:10px; white-space:pre-line; }
    .badge { padding:4px 10px; border-radius:999px; background:var(--surface-2); border:1px solid var(--edge); color:var(--sub); font-size:12px; }
    .spacer { height:16px; }
    a { color: var(--accent); text-decoration: none; }
    .grid { display:grid; gap:12px; }
    .two { grid-template-columns:1fr 1fr; }
    @media (max-width:840px){ .two { grid-template-columns:1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Mezo Plays Pokémon</h1>
      <p>Send on-chain inputs to the <code>ChainPlays</code> contract deployed on Mezo Mainnet. Each press calls <code>move(cmd, memo)</code> and emits a <code>Move</code> event.</p>

      <div class="row" style="margin-bottom:8px">
        <label class="badge">Contract</label>
        <input id="contract" value="0x7c8A35C98Bf46a67324Af3F54aD027DBE2138E98" style="min-width:320px" />
        <label class="badge">Chain</label>
        <select id="chain" style="height:44px;border-radius:10px;background:#0e1520;color:var(--text);border:1px solid #2a3a4f;">
          <option value="31612" selected>Mezo Mainnet (31612)</option>
          <option value="31611">Mezo Testnet (31611)</option>
        </select>
        <button id="saveCfg">Save</button>
      </div>

      <!-- Smart Wallet Panel (simplified) -->
      <div class="row" id="walletPanel1" style="margin-bottom:8px">
        <label class="badge">Owner</label>
        <div id="ownerAddr" class="stat" style="min-width:300px">—</div>
        <label class="badge">Owner Balance</label>
        <div id="ownerBal" class="stat">—</div>
      </div>
      <div class="row" id="walletPanel2" style="margin-bottom:8px">
        <label class="badge">Smart Wallet</label>
        <input id="walletAddr" readonly style="min-width:340px" placeholder="(not created)" />
        <button id="btnCreateWallet" class="primary">Create My Wallet</button>
        <input id="createAmt" placeholder="Amount (BTC)" style="width:180px" />
        <button id="btnCreateAndFund" class="primary">Create + Fund</button>
      </div>
      <div class="row" id="walletPanel3" style="margin-bottom:8px; display:none;">
        <label class="badge">Wallet Balance</label>
        <div id="walletBal" class="stat">—</div>
        <input id="fundAmt" placeholder="Amount (BTC)" style="width:180px" />
        <button id="btnFund" class="primary">Fund</button>
        <button id="btnRefresh" class="secondary">Refresh</button>
        <button id="btnEnableGasless" class="secondary" style="display:none">Enable Gasless</button>
      </div>

      <div class="row">
        <button id="connect" class="primary">Connect Wallet</button>
        <div id="acct" class="stat">Not connected</div>
        <div id="net" class="badge">Network: —</div>
        <a id="expl" class="badge" href="https://explorer.mezo.org/address/0x7c8A35C98Bf46a67324Af3F54aD027DBE2138E98" target="_blank" rel="noreferrer">Open in Explorer</a>
      </div>

      <div class="spacer"></div>
      <div class="grid two">
        <div>
          <div class="pad">
            <div></div>
            <button data-cmd="0">↑ Up</button>
            <div></div>
            <button data-cmd="2">← Left</button>
            <button data-cmd="1">↓ Down</button>
            <button data-cmd="3">→ Right</button>
          </div>
          <div class="keys">
            <button data-cmd="4">A</button>
            <button data-cmd="5">B</button>
            <button data-cmd="6">Start</button>
            <button data-cmd="7">Select</button>
          </div>
        </div>
        <div>
          <div class="row">
            <input id="memo" placeholder="Optional memo (e.g., 'Go!')" style="flex:1;min-width:260px" />
            <button id="send" class="primary">Send Last Click</button>
          </div>
          <div class="spacer"></div>
          <div class="grid">
            <div class="stat" id="status">Status: idle</div>
            <div class="stat" id="gas">Gas est.: —</div>
            <div class="stat" id="last">Last tx: —</div>
            <div class="stat" id="events">Recent events (client-side): none</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Ethers v5 (UMD) for injected wallets like MetaMask/Rabby) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Relayer config injected -->
  <script>
    window.RELAYER_URL = "https://mezo-relayer.onrender.com/relay";
    window.RELAYER_ADDRESS = "0x974A813950E168c81e4C6B352b3e81A77e80af90";
    try {
      localStorage.setItem('relayerUrl', window.RELAYER_URL);
      localStorage.setItem('relayerAddress', window.RELAYER_ADDRESS);
    } catch (e) {}
  </script>
  <!-- Early safety wrapper: coerce any 0x7B6C/31596 add/switch to 0x7B7C (31612) -->
  <script>
    (function earlyMezoWrap(){
      const eth = window.ethereum; if(!eth || eth.__mezoWrappedEarly) return;
      const orig = eth.request.bind(eth);
      const MEZO_HEX='0x7b7c';
      const MEZO_PARAMS={
        chainId: MEZO_HEX,
        chainName:'Mezo Mainnet',
        nativeCurrency:{name:'Bitcoin',symbol:'BTC',decimals:18},
        rpcUrls:['https://mainnet.mezo.public.validationcloud.io'],
        blockExplorerUrls:['https://explorer.mezo.org']
      };
      eth.request = (args)=>{
        try{
          if(args?.method==='wallet_addEthereumChain'){
            const p = Array.isArray(args.params)&&args.params[0]?{...args.params[0]}:{};
            const id=String(p.chainId||'').toLowerCase();
            if(id==='0x7b6c'||id==='31596'){ return orig({ ...args, params:[MEZO_PARAMS] }); }
          }
          if(args?.method==='wallet_switchEthereumChain'){
            const p = Array.isArray(args.params)&&args.params[0]?{...args.params[0]}:{};
            const id=String(p.chainId||'').toLowerCase();
            if(id==='0x7b6c'||id==='31596'){ return orig({ ...args, params:[{chainId:MEZO_HEX}] }); }
          }
        }catch(_){}
        return orig(args);
      };
      eth.__mezoWrappedEarly = true;
    })();
  </script>
  <script>
    (function(){
      const ethers = window.ethers; // v5 UMD

      // === Mezo chain config ===
      const MEZO_MAINNET = 31612;
      const MEZO_PARAMS = {
        chainId: '0x7B7C',
        chainName: 'Mezo Mainnet',
        nativeCurrency: { name: 'Bitcoin', symbol: 'BTC', decimals: 18 },
        rpcUrls: ['https://mainnet.mezo.public.validationcloud.io'],
        blockExplorerUrls: ['https://explorer.mezo.org']
      };

      // === ABI ===
      const ABI = [
        'function move(uint8 cmd, string memo)',
        'event Move(address indexed sender, uint8 cmd, uint256 weight, string memo)'
      ];

      // GasTankWallet ABI (subset)
      const WABI = [
        'function deposit() payable',
        'function withdraw(uint256 amount, address payable to)',
        'function setRelayer(address r)',
        'function relayer() view returns (address)',
        'function owner() view returns (address)',
        'function relayMove(uint8 cmd, string memo)',
        'function sessionKey() view returns (address)',
        'function sessionKeyExpiry() view returns (uint64)'
      ];

      // === GasTankFactory V3 ===
      const FACTORY_ADDR_MAINNET = '0xcBcdB04C6D8b90850C3F248a0FE2777C09E2Ed48';
      const FABI = [
        'function walletOf(address owner) view returns (address)',
        'function defaultRelayer() view returns (address)',
        'function create(address owner) payable returns (address)',
        'function createAndDeposit(address owner) payable returns (address)',
        'event WalletCreated(address indexed wallet, address indexed owner, uint256 initialDeposit)'
      ];

      // Relayer config (from window or localStorage)
      let RELAYER_URL = (window.RELAYER_URL || localStorage.getItem('relayerUrl') || '').trim();
      let RELAYER_ADDRESS = ((window.RELAYER_ADDRESS || localStorage.getItem('relayerAddress') || '') + '').toLowerCase();

      // === DOM ===
      const $ = (id) => document.getElementById(id);
      const connectBtn   = $('connect');
      const padButtons   = Array.from(document.querySelectorAll('[data-cmd]'));
      const acctEl       = $('acct');
      const netEl        = $('net');
      const statusEl     = $('status');
      const gasEl        = $('gas');
      const lastEl       = $('last');
      const eventsEl     = $('events');
      const contractInput= $('contract');
      const chainSelect  = $('chain');
      const ownerAddrEl  = $('ownerAddr');
      const ownerBalEl   = $('ownerBal');
      const walletAddrEl = $('walletAddr');
      const btnCreateWallet   = $('btnCreateWallet');
      const walletBalEl       = $('walletBal');
      const fundAmtEl         = $('fundAmt');
      const btnFund           = $('btnFund');
      const btnRefresh        = $('btnRefresh');
      const btnEnableGasless  = $('btnEnableGasless');
      const createAmtEl       = $('createAmt');
      const btnCreateAndFund  = $('btnCreateAndFund');

      let provider, signer, contract, lastCmd = null, sending = false;
      let walletContract = null; // GasTankWallet instance

      function say(msg){ statusEl.textContent = msg; }

      function explorerBase(){
        return Number(chainSelect.value) === MEZO_MAINNET ? 'https://explorer.mezo.org' : 'https://explorer.test.mezo.org';
      }
      function updateExplorerLink(){
        try {
          const addr = (contractInput?.value || '').trim();
          if (!addr) return;
          const a = document.getElementById('expl');
          if (a) a.href = explorerBase() + '/address/' + addr;
        } catch (e) { console.error('updateExplorerLink error', e); }
      }
      updateExplorerLink();

      async function ensureInjected(){
        if (!window.ethereum){
          say('No injected wallet found. Install MetaMask/Rabby/OKX or open in the wallet\'s in-app browser.');
          throw new Error('no-injected-wallet');
        }
        if (!provider) provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        const accs = await provider.listAccounts();
        if (accs.length === 0) await provider.send('eth_requestAccounts', []);
        signer = provider.getSigner();
        const addr = await signer.getAddress();
        const net  = await provider.getNetwork();
        acctEl.textContent = `Player: ${addr}`;
        netEl.textContent  = `Network: ${net.chainId}`;
        if (net.chainId !== MEZO_MAINNET){
          try {
            await window.ethereum.request({ method:'wallet_switchEthereumChain', params:[{ chainId: MEZO_PARAMS.chainId }] });
          } catch (e){
            if (e.code === 4902 || String(e.message).includes('Unrecognized chain')){
              await window.ethereum.request({ method:'wallet_addEthereumChain', params:[MEZO_PARAMS] });
            } else { throw e; }
          }
          provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
          signer = provider.getSigner();
          const net2 = await provider.getNetwork();
          netEl.textContent = `Network: ${net2.chainId}`;
        }
        return { addr: await signer.getAddress() };
      }

      function getContract(){
        const addr = contractInput.value.trim();
        if (!addr) throw new Error('Missing contract address');
        return new ethers.Contract(addr, ABI, signer || provider);
      }

      async function onConnect(){
        try {
          say('Connecting…');
          const { addr } = await ensureInjected();
          contract = getContract().connect(signer);
          ownerAddrEl.textContent = addr;

          // learn default relayer + existing wallet
          const fab = new ethers.Contract(FACTORY_ADDR_MAINNET, FABI, signer);
          if (!RELAYER_ADDRESS) {
            try { const d = await fab.defaultRelayer(); RELAYER_ADDRESS = d.toLowerCase(); localStorage.setItem('relayerAddress', RELAYER_ADDRESS); } catch {}
          }
          const existing = await fab.walletOf(addr);
          if (existing && existing !== ethers.constants.AddressZero) {
            walletAddrEl.value = existing;
            walletContract = new ethers.Contract(existing, WABI, signer);
            document.getElementById('walletPanel3').style.display = 'flex';
            if (btnCreateWallet) btnCreateWallet.style.display = 'none';
            if (btnCreateAndFund) btnCreateAndFund.style.display = 'none';
            if (createAmtEl) createAmtEl.style.display = 'none';
          } else {
            walletAddrEl.value = '';
            document.getElementById('walletPanel3').style.display = 'none';
            if (btnCreateWallet) btnCreateWallet.style.display = 'inline-block';
            if (btnCreateAndFund) btnCreateAndFund.style.display = 'inline-block';
            if (createAmtEl) createAmtEl.style.display = 'inline-block';
          }

          try { contract.on('Move', (sender, cmd, weight, memo, ev) => { appendEvent({ sender, cmd: Number(cmd), memo, txHash: ev.transactionHash }); }); } catch {}

          await ensureGaslessReady();
          await refreshOwnerBalance();
          await refreshWalletBalance();
          say('Status: connected');
        } catch (err){ console.error(err); say('Connect error: ' + (err?.message || err)); }
      }

      function appendEvent(e){
        const now = new Date().toLocaleTimeString();
        const hash = (e.txHash || e.txhash || e.hash || '').slice(0, 10) || '—';
        const line = `[${now}] ${e.sender} → cmd=${e.cmd} memo="${e.memo}" tx=${hash}`;
        const prev = eventsEl.textContent;
        eventsEl.textContent = prev === 'Recent events (client-side): none' ? line : prev + "
" + line;
      }

      async function ensureGaslessReady(){
        try{
          if (!walletAddrEl.value || !RELAYER_ADDRESS) return;
          const w = new ethers.Contract(walletAddrEl.value, WABI, signer);
          const r = (await w.relayer()).toLowerCase();
          if (btnEnableGasless){
            if (r !== (RELAYER_ADDRESS||'').toLowerCase()){
              btnEnableGasless.style.display = 'inline-block';
              btnEnableGasless.textContent = 'Enable Gasless (1 tx)';
              say('Gasless not enabled yet — click "Enable Gasless" once.');
            } else {
              btnEnableGasless.style.display = 'none';
            }
          }
        } catch(e){ console.warn('ensureGaslessReady', e); }
      }

      async function send(cmd, memo){
        if (walletAddrEl.value && RELAYER_URL) {
          if (btnEnableGasless && btnEnableGasless.style.display !== 'none'){
            say('Enable gasless first (click the button above)');
            return;
          }
          try {
            say('Relaying via server…');
            const res = await fetch(RELAYER_URL, {
              method: 'POST', headers: { 'content-type': 'application/json' },
              body: JSON.stringify({ wallet: walletAddrEl.value, cmd, memo, chainId: MEZO_MAINNET })
            });
            const out = await res.json().catch(()=>({}));
            if (!res.ok) throw new Error(out?.error || res.statusText);
            lastEl.textContent = 'Last tx: ' + (out.hash || out.txhash || out.txHash || '—');
            say('Relayed');
            return;
          } catch (e) {
            console.warn('Relayer failed', e);
            say('Relayer error: ' + (e?.message || e));
            return; // do not fall back to EOA path
          }
        }

        if (walletAddrEl.value) {
          try{
            if (!walletContract) walletContract = new ethers.Contract(walletAddrEl.value, WABI, signer);
            say('Sending via smart wallet…');
            const tx = await walletContract.relayMove(cmd, memo, { gasLimit: 500000 });
            lastEl.textContent = 'Last tx: ' + tx.hash;
            const rc = await tx.wait();
            say('Smart wallet relayed in block ' + rc.blockNumber);
          } catch(e){ console.error(e); say('Smart wallet error: ' + (e?.message || e)); }
          return;
        }

        try {
          say('Sending…');
          const tx = await contract.move(cmd, memo, { gasLimit: 300000 });
          lastEl.textContent = 'Last tx: ' + tx.hash;
          const rc = await tx.wait();
          say('Mined in block ' + rc.blockNumber);
        } catch (e){ console.error(e); say('Error: ' + (e?.error?.message || e?.data?.message || e?.message || e)); }
      }

      if (window.ethereum?.on) {
        window.ethereum.on('chainChanged', async (_cid) => {
          try {
            provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
            signer = provider.getSigner();
            const net = await provider.getNetwork();
            netEl.textContent = `Network: ${net.chainId}`;
          } catch (e) { statusEl.textContent = 'Reconnected after chain change'; }
        });
      }

      // UI wiring
      function bindConnect(){
        if (!connectBtn) return;
        connectBtn.onclick = async (ev) => {
          try { ev?.preventDefault?.(); await onConnect(); }
          catch (err){ console.error(err); statusEl.textContent = 'Connect error: ' + (err?.message || err); alert('Wallet connect failed: ' + (err?.message || err)); }
        };
      }
      window.onConnect = onConnect;
      bindConnect();
      window.addEventListener('DOMContentLoaded', bindConnect);
      window.addEventListener('load', bindConnect);

      function setPadDisabled(disabled){ padButtons.forEach(b=>b.disabled = !!disabled); }

      padButtons.forEach(btn => btn.addEventListener('click', async () => {
        try {
          lastCmd = Number(btn.dataset.cmd);
          const memo = $('memo').value || '';
          if (!contract) { alert('Connect first.'); return; }
          setPadDisabled(true);
          await send(lastCmd, memo);
        } finally { setPadDisabled(false); }
      }));
      $('send').onclick = async () => {
        if (lastCmd === null){ alert('Press a command button first.'); return; }
        await send(lastCmd, $('memo').value || '');
      };

      async function refreshOwnerBalance(){
        try{ const bal = await provider.getBalance(await signer.getAddress()); ownerBalEl.textContent = ethers.utils.formatUnits(bal, 18) + ' BTC'; } catch {}
      }
      async function refreshWalletBalance(){
        try{ const waddr = walletAddrEl.value.trim(); if (!waddr) { walletBalEl.textContent = '—'; return; } const bal = await provider.getBalance(waddr); walletBalEl.textContent = ethers.utils.formatUnits(bal, 18) + ' BTC'; } catch { walletBalEl.textContent = '—'; }
      }

      btnCreateWallet?.addEventListener('click', async () => {
        try {
          await ensureInjected();
          const owner = await signer.getAddress();
          const fab   = new ethers.Contract(FACTORY_ADDR_MAINNET, FABI, signer);
          say('Creating wallet…');
          const tx = await fab.create(owner);
          const rc = await tx.wait();
          let wallet;
          try { const ev = rc.events?.find(e=>e.event==='WalletCreated'); if (ev?.args?.wallet) wallet = ev.args.wallet; } catch {}
          if (!wallet) wallet = await fab.walletOf(owner);
          walletAddrEl.value = wallet;
          walletContract = new ethers.Contract(wallet, WABI, signer);
          document.getElementById('walletPanel3').style.display = 'flex';
          if (btnCreateWallet) btnCreateWallet.style.display = 'none';
          // try to set relayer automatically (one-time owner tx)
          try { if (RELAYER_ADDRESS){ const tx2 = await walletContract.setRelayer(RELAYER_ADDRESS); await tx2.wait(); } } catch(_){ }
          await ensureGaslessReady();
          say('Wallet ready: ' + wallet);
          await refreshWalletBalance();
        } catch(e){ say('Create failed: ' + (e?.message || e)); }
      });

      btnCreateAndFund?.addEventListener('click', async () => {
        try {
          await ensureInjected();
          const owner = await signer.getAddress();
          const amt   = createAmtEl.value.trim();
          if (!amt) { alert('Enter amount'); return; }
          const value = ethers.utils.parseUnits(amt, 18);
          const fab   = new ethers.Contract(FACTORY_ADDR_MAINNET, FABI, signer);
          say('Creating wallet & funding…');
          const tx = await fab.createAndDeposit(owner, { value });
          const rc = await tx.wait();
          let wallet;
          try { const ev = rc.events?.find(e=>e.event==='WalletCreated'); if (ev?.args?.wallet) wallet = ev.args.wallet; } catch {}
          if (!wallet) wallet = await fab.walletOf(owner);
          walletAddrEl.value = wallet;
          walletContract = new ethers.Contract(wallet, WABI, signer);
          document.getElementById('walletPanel3').style.display = 'flex';
          if (btnCreateWallet) btnCreateWallet.style.display = 'none';
          if (btnCreateAndFund) btnCreateAndFund.style.display = 'none';
          if (createAmtEl) createAmtEl.style.display = 'none';
          // set relayer automatically after creation
          try { if (RELAYER_ADDRESS){ const tx2 = await walletContract.setRelayer(RELAYER_ADDRESS); await tx2.wait(); } } catch(_){ }
          await refreshOwnerBalance();
          await refreshWalletBalance();
          await ensureGaslessReady();
          say('Wallet ready & funded.');
        } catch(e){ say('Create+Fund failed: ' + (e?.message || e)); }
      });

      btnFund?.addEventListener('click', async () => {
        try {
          if (!walletAddrEl.value) return alert('Create a wallet first');
          const amt = fundAmtEl.value.trim(); if (!amt) return alert('Enter amount');
          const w = new ethers.Contract(walletAddrEl.value, WABI, signer);
          say('Funding wallet…');
          const tx = await w.deposit({ value: ethers.utils.parseUnits(amt, 18) });
          await tx.wait();
          await refreshWalletBalance();
          say('Funded');
        } catch(e){ say('Fund failed: ' + (e?.message || e)); }
      });

      btnRefresh?.addEventListener('click', async () => { await refreshOwnerBalance(); await refreshWalletBalance(); });

      btnEnableGasless?.addEventListener('click', async () => {
        try{
          if (!RELAYER_URL || !RELAYER_ADDRESS) { alert('Relayer not configured'); return; }
          if (!walletAddrEl.value) { alert('Create a wallet first'); return; }
          const w = new ethers.Contract(walletAddrEl.value, WABI, signer);
          say('Enabling gasless…');
          const tx = await w.setRelayer(RELAYER_ADDRESS);
          await tx.wait();
          await ensureGaslessReady();
          say('Gasless enabled');
        } catch(e){ say('Enable failed: ' + (e?.message || e)); }
      });

      function keyToCmd(evt){
        const k = evt.key;
        if (k === 'ArrowUp') return 0; if (k === 'ArrowDown') return 1; if (k === 'ArrowLeft') return 2; if (k === 'ArrowRight') return 3;
        if (k && k.length === 1 && k.toLowerCase() === 'a') return 4; if (k && k.length === 1 && k.toLowerCase() === 'b') return 5;
        if (k === 'Enter') return 6; if (k === 'Shift') return 7; return null;
      }
      document.addEventListener('keydown', async (evt) => {
        const cmd = keyToCmd(evt); if (cmd === null) return; evt.preventDefault(); if (!contract) { alert('Connect first.'); return; }
        if (evt.repeat || sending) return; try { sending = true; setPadDisabled(true); await send(cmd, $('memo').value || ''); } finally { sending = false; setPadDisabled(false); }
      });
    })();
  </script>
  <script>
    (function(){
      function wrapAddChain(){
        const eth = window.ethereum; if(!eth || eth.__mezoWrapped) return;
        const orig = eth.request.bind(eth);
        eth.request = async (args) => {
          try {
            if(args?.method === 'wallet_addEthereumChain'){
              const p = Array.isArray(args.params) ? { ...(args.params[0]||{}) } : {};
              const id = String(p.chainId||'').toLowerCase();
              if(id === '0x7b6c' || id === '31596'){
                p.chainId = '0x7B7C';
                p.chainName = p.chainName || 'Mezo Mainnet';
                p.rpcUrls = ['https://mainnet.mezo.public.validationcloud.io'];
                p.blockExplorerUrls = ['https://explorer.mezo.org'];
                p.nativeCurrency = { name:'Bitcoin', symbol:'BTC', decimals:18 };
                return orig({ ...args, params:[p] });
              }
            }
            if(args?.method === 'wallet_switchEthereumChain'){
              const p = Array.isArray(args.params) ? { ...(args.params[0]||{}) } : {};
              const id = String(p.chainId||'').toLowerCase();
              if(id === '0x7b6c'){
                p.chainId = '0x7B7C';
                return orig({ ...args, params:[p] });
              }
            }
          } catch(e) { /* fall through to original */ }
          return orig(args);
        };
        eth.__mezoWrapped = true;
      }
      window.addEventListener('DOMContentLoaded', wrapAddChain);
    })();
  </script>

  <!-- Fallback connector: if main script fails to bind, still open wallet prompt -->
  <script>
    (function(){
      const btn = document.getElementById('connect');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        try {
          if (typeof window.onConnect === 'function') {
            // main handler exists
            return;
          }
          if (!window.ethereum) { alert('No injected wallet found (MetaMask/Rabby/OKX).'); return; }
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          const accs = await window.ethereum.request({ method: 'eth_accounts' });
          const acctEl = document.getElementById('acct');
          if (acctEl) acctEl.textContent = accs[0] ? ('Player: ' + accs[0]) : 'Not connected';
        } catch (e) {
          console.error(e);
          alert('Wallet connect failed: ' + (e?.message || e));
        }
      }, { capture: true });
    })();
  </script>
</body>
</html>
